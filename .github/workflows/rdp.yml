name: Optimized High Performance RDP Tunnel
on:
  workflow_dispatch:
jobs:
  setup-optimized-rdp:
    runs-on: windows-latest
    timeout-minutes: 360  # 6 hours
    steps:
    - name: Check out the repository
      uses: actions/checkout@v4
    
    - name: Intelligent Performance Optimization
      run: |
        Write-Host "üöÄ Applying intelligent performance optimizations..."
        
        # Set to High Performance power scheme (stable and fast)
        try {
            # Try Ultimate Performance first, fallback to High Performance
            $ultimateGuid = "e9a42b02-d5df-448d-aa00-03f14749eb61"
            powercfg -duplicatescheme $ultimateGuid 2>$null
            $schemes = powercfg -list
            if ($schemes -match $ultimateGuid) {
                powercfg -setactive $ultimateGuid
                Write-Host "‚úÖ Ultimate Performance scheme activated"
            } else {
                powercfg -setactive SCHEME_MIN
                Write-Host "‚úÖ High Performance scheme activated"
            }
        } catch {
            powercfg -setactive SCHEME_MIN
            Write-Host "‚úÖ High Performance scheme activated (fallback)"
        }
        
        # Optimize power settings for consistent performance
        powercfg -change standby-timeout-ac 0
        powercfg -change hibernate-timeout-ac 0
        powercfg -change disk-timeout-ac 0
        powercfg -change monitor-timeout-ac 180  # Keep monitor on for 3 hours
        powercfg -hibernate off
        
        # CPU optimization - balanced approach
        try {
            $guid = (powercfg -getactivescheme | Select-String -Pattern "\b[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}\b").Matches[0].Value
            
            # Set CPU to high performance but not extreme
            powercfg -setacvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMAX 100
            powercfg -setacvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMIN 80  # 80% minimum instead of 100%
            
            # Optimize core parking - don't disable completely
            powercfg -setacvalueindex $guid SUB_PROCESSOR CPMINCORES 50
            powercfg -setacvalueindex $guid SUB_PROCESSOR CPMAXCORES 100
            
            # Enable performance boost
            powercfg -setacvalueindex $guid SUB_PROCESSOR PERFBOOSTMODE 1
            powercfg -setacvalueindex $guid SUB_PROCESSOR PERFBOOSTPOL 2  # Aggressive but stable
            
            powercfg -setactive $guid
            Write-Host "‚úÖ CPU optimized for high performance with stability"
        } catch {
            Write-Host "‚ö†Ô∏è Some CPU optimizations skipped - using defaults"
        }
        
        # Optimize memory management
        try {
            $totalRAM = [math]::Round((Get-CimInstance Win32_PhysicalMemory | Measure-Object -Property capacity -Sum).sum / 1GB)
            $pagefileSize = [math]::Max(2048, $totalRAM * 1024)  # 1x RAM instead of 2x
            
            # Configure managed pagefile for stability
            $cs = Get-CimInstance -ClassName Win32_ComputerSystem
            if (-not $cs.AutomaticManagedPagefile) {
                Set-CimInstance -InputObject $cs -Property @{AutomaticManagedPagefile=$true}
                Write-Host "‚úÖ Using system-managed pagefile for stability"
            }
        } catch {
            Write-Host "‚úÖ Using default memory management"
        }
        
        # Safe priority optimization
        Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name "Win32PrioritySeparation" -Value 26 -ErrorAction SilentlyContinue
        
        Write-Host "‚úÖ Performance optimization completed"
    
    - name: Optimize Visual Effects for RDP
      run: |
        Write-Host "üé® Optimizing visual effects for RDP performance..."
        
        # Set to custom performance settings
        $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer"
        Set-ItemProperty -Path "$regPath\VisualEffects" -Name "VisualFXSetting" -Value 2 -ErrorAction SilentlyContinue
        
        # Disable resource-intensive visual effects
        $advancedPath = "$regPath\Advanced"
        $visualSettings = @{
            "ListviewAlphaSelect" = 0
            "TaskbarAnimations" = 0
            "ListviewShadow" = 0
        }
        
        foreach ($setting in $visualSettings.GetEnumerator()) {
            Set-ItemProperty -Path $advancedPath -Name $setting.Key -Value $setting.Value -ErrorAction SilentlyContinue
        }
        
        # Desktop optimizations
        $desktopPath = "HKCU:\Control Panel\Desktop"
        Set-ItemProperty -Path $desktopPath -Name "MenuShowDelay" -Value 100 -ErrorAction SilentlyContinue  # Slight delay instead of 0
        Set-ItemProperty -Path $desktopPath -Name "DragFullWindows" -Value 0 -ErrorAction SilentlyContinue
        
        # Disable transparency for better RDP performance
        Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize" -Name "EnableTransparency" -Value 0 -ErrorAction SilentlyContinue
        
        Write-Host "‚úÖ Visual effects optimized for RDP"
    
    - name: Smart Service Optimization
      run: |
        Write-Host "‚öôÔ∏è Optimizing services intelligently..."
        
        # Only disable truly non-essential services that don't affect RDP stability
        $safeToDisableServices = @(
            "DiagTrack",           # Diagnostics Tracking
            "dmwappushservice",    # Device Management WAP
            "MapsBroker",          # Downloaded Maps Manager
            "lfsvc",               # Geolocation Service
            "WMPNetworkSvc",       # Windows Media Player Network
            "XblAuthManager",      # Xbox Live Auth Manager
            "XblGameSave",         # Xbox Live Game Save
            "XboxGipSvc",          # Xbox Accessory Management
            "XboxNetApiSvc",       # Xbox Live Networking
            "Fax"                  # Fax Service
        )
        
        $servicesOptimized = 0
        foreach ($serviceName in $safeToDisableServices) {
            try {
                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                if ($service -and $service.Status -eq "Running") {
                    Stop-Service -Name $serviceName -Force -ErrorAction SilentlyContinue
                    Set-Service -Name $serviceName -StartupType Disabled -ErrorAction SilentlyContinue
                    $servicesOptimized++
                    Write-Host "‚úÖ Optimized service: $serviceName"
                }
            } catch {
                Write-Host "‚ö†Ô∏è Could not optimize service: $serviceName"
            }
        }
        
        # Keep essential services running for RDP stability
        $essentialServices = @("TermService", "SessionEnv", "UmRdpService", "RpcSs", "RpcEptMapper")
        foreach ($serviceName in $essentialServices) {
            try {
                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                if ($service) {
                    Set-Service -Name $serviceName -StartupType Automatic -ErrorAction SilentlyContinue
                    if ($service.Status -ne "Running") {
                        Start-Service -Name $serviceName -ErrorAction SilentlyContinue
                    }
                    Write-Host "‚úÖ Ensured service is running: $serviceName"
                }
            } catch {
                Write-Host "‚ö†Ô∏è Could not verify service: $serviceName"
            }
        }
        
        Write-Host "‚úÖ Services optimized: $servicesOptimized services configured"
    
    - name: Safe System Cleanup
      run: |
        Write-Host "üßπ Performing safe system cleanup..."
        
        # Clean temporary files safely
        $cleanupPaths = @(
            "$env:TEMP",
            "$env:WINDIR\Temp",
            "$env:WINDIR\Prefetch",
            "$env:LOCALAPPDATA\Temp"
        )
        
        $totalCleaned = 0
        foreach ($path in $cleanupPaths) {
            try {
                if (Test-Path $path) {
                    $itemsBefore = (Get-ChildItem $path -ErrorAction SilentlyContinue).Count
                    Get-ChildItem $path -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                    $itemsAfter = (Get-ChildItem $path -ErrorAction SilentlyContinue).Count
                    $cleaned = $itemsBefore - $itemsAfter
                    $totalCleaned += $cleaned
                    if ($cleaned -gt 0) {
                        Write-Host "‚úÖ Cleaned $cleaned items from $path"
                    }
                }
            } catch {
                Write-Host "‚ö†Ô∏è Could not clean some items in $path"
            }
        }
        
        # Safe event log cleanup
        try {
            $safeLogs = @("Application", "System")
            foreach ($logName in $safeLogs) {
                $log = Get-WinEvent -ListLog $logName -ErrorAction SilentlyContinue
                if ($log -and $log.RecordCount -gt 1000) {
                    wevtutil cl $logName 2>$null
                    Write-Host "‚úÖ Cleaned event log: $logName"
                }
            }
        } catch {
            Write-Host "‚ö†Ô∏è Event log cleanup completed with warnings"
        }
        
        # Force garbage collection
        [System.GC]::Collect()
        [System.GC]::WaitForPendingFinalizers()
        
        Write-Host "‚úÖ Cleanup completed: $totalCleaned items processed"
    
    - name: Download and Setup Playit Agent
      run: |
        Write-Host "üì• Setting up Playit Agent..."
        try {
            $playitUrl = "https://github.com/playit-cloud/playit-agent/releases/download/v0.15.26/playit-windows-x86_64-signed.exe"
            $playitPath = "$env:USERPROFILE\playit.exe"
            
            Invoke-WebRequest -Uri $playitUrl -OutFile $playitPath -UseBasicParsing
            
            # Verify download
            if (Test-Path $playitPath) {
                $fileSize = (Get-Item $playitPath).Length
                Write-Host "‚úÖ Playit Agent downloaded successfully ($([math]::Round($fileSize/1MB, 2)) MB)"
            } else {
                throw "Download verification failed"
            }
        } catch {
            Write-Host "‚ùå Error downloading Playit Agent: $($_.Exception.Message)"
            exit 1
        }
    
    - name: Configure Stable RDP Settings
      run: |
        Write-Host "üñ•Ô∏è Configuring stable RDP settings..."
        
        # Enable Remote Desktop with proper configuration
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fSingleSessionPerUser" -Value 0  # Allow multiple sessions
        
        # Configure firewall for RDP
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop" -ErrorAction SilentlyContinue
        New-NetFirewallRule -DisplayName "RDP-In-TCP" -Direction Inbound -Protocol TCP -LocalPort 3389 -Action Allow -ErrorAction SilentlyContinue
        
        # Ensure Terminal Services are properly configured
        $termServices = @("TermService", "SessionEnv", "UmRdpService")
        foreach ($service in $termServices) {
            try {
                Set-Service -Name $service -StartupType Automatic -ErrorAction SilentlyContinue
                Start-Service -Name $service -ErrorAction SilentlyContinue
                Write-Host "‚úÖ Terminal service configured: $service"
            } catch {
                Write-Host "‚ö†Ô∏è Could not configure service: $service"
            }
        }
        
        # Optimize RDP settings for stability and performance
        $rdpPath = 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp'
        
        # Connection limits - reasonable values
        Set-ItemProperty -Path $rdpPath -Name "MaxInstanceCount" -Value 10 -ErrorAction SilentlyContinue
        Set-ItemProperty -Path $rdpPath -Name "MaxConnectionTime" -Value 0 -ErrorAction SilentlyContinue  # No limit
        Set-ItemProperty -Path $rdpPath -Name "MaxIdleTime" -Value 21600000 -ErrorAction SilentlyContinue  # 6 hours in ms
        Set-ItemProperty -Path $rdpPath -Name "MaxDisconnectionTime" -Value 60000 -ErrorAction SilentlyContinue  # 60 seconds
        
        # Performance settings - balanced
        Set-ItemProperty -Path $rdpPath -Name "ColorDepth" -Value 4 -ErrorAction SilentlyContinue  # 32-bit color
        Set-ItemProperty -Path $rdpPath -Name "fDisableWallpaper" -Value 1 -ErrorAction SilentlyContinue
        Set-ItemProperty -Path $rdpPath -Name "fDisableMenuAnims" -Value 1 -ErrorAction SilentlyContinue
        Set-ItemProperty -Path $rdpPath -Name "fDisableTheming" -Value 0 -ErrorAction SilentlyContinue  # Keep themes for stability
        Set-ItemProperty -Path $rdpPath -Name "fDisableFullWindowDrag" -Value 1 -ErrorAction SilentlyContinue
        
        # Enable bitmap caching for better performance
        Set-ItemProperty -Path $rdpPath -Name "fEnableBitmapCache" -Value 1 -ErrorAction SilentlyContinue
        Set-ItemProperty -Path $rdpPath -Name "BitmapCacheSize" -Value 16384 -ErrorAction SilentlyContinue  # 16MB cache
        
        # Keep audio redirection enabled but optimized
        Set-ItemProperty -Path $rdpPath -Name "fDisableAudioCapture" -Value 0 -ErrorAction SilentlyContinue
        
        # Network Level Authentication for security
        Set-ItemProperty -Path $rdpPath -Name "UserAuthentication" -Value 1 -ErrorAction SilentlyContinue
        
        Write-Host "‚úÖ RDP configured for stable high performance"
    
    - name: Create Secure RDP Administrator
      run: |
        Write-Host "üë§ Creating secure RDP administrator..."
        
        # Generate secure password
        $password = ConvertTo-SecureString "RdpAdmin2024#$(Get-Random -Minimum 1000 -Maximum 9999)" -AsPlainText -Force
        $username = "rdpadmin"
        
        try {
            # Remove existing user if present
            if (Get-LocalUser -Name $username -ErrorAction SilentlyContinue) {
                Remove-LocalUser -Name $username -ErrorAction SilentlyContinue
                Write-Host "‚úÖ Removed existing user"
            }
            
            # Create new administrator user
            New-LocalUser -Name $username -Password $password -FullName "RDP Administrator" -Description "Secure RDP Administrator Account" -PasswordNeverExpires -UserMayNotChangePassword
            
            # Add to necessary groups
            Add-LocalGroupMember -Group "Administrators" -Member $username
            Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username
            
            # Set account policies
            net accounts /maxpwage:unlimited 2>$null
            
            # Display credentials securely
            $plainPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))
            Write-Host "‚úÖ RDP Administrator created successfully"
            Write-Host "üìã CONNECTION CREDENTIALS:"
            Write-Host "   üë§ Username: $username"
            Write-Host "   üîë Password: $plainPassword"
            Write-Host "   üîê Access Level: Administrator"
            
            # Store credentials for later use
            $env:RDP_USERNAME = $username
            $env:RDP_PASSWORD = $plainPassword
            
        } catch {
            Write-Host "‚ùå Error creating RDP user: $($_.Exception.Message)"
            # Create fallback user
            try {
                $fallbackPassword = ConvertTo-SecureString "FallbackUser2024!" -AsPlainText -Force
                New-LocalUser -Name "rdpuser" -Password $fallbackPassword -FullName "RDP User" -Description "Fallback RDP User" -PasswordNeverExpires
                Add-LocalGroupMember -Group "Remote Desktop Users" -Member "rdpuser"
                Add-LocalGroupMember -Group "Administrators" -Member "rdpuser"
                Write-Host "‚úÖ Fallback user created: rdpuser / FallbackUser2024!"
                $env:RDP_USERNAME = "rdpuser"
                $env:RDP_PASSWORD = "FallbackUser2024!"
            } catch {
                Write-Host "‚ùå Failed to create any RDP user"
                exit 1
            }
        }
    
    - name: Apply Final System Optimizations
      run: |
        Write-Host "üîß Applying final system optimizations..."
        
        # Safe Windows Defender optimization
        try {
            # Add exclusions instead of disabling completely
            Add-MpPreference -ExclusionPath "$env:USERPROFILE" -ErrorAction SilentlyContinue
            Add-MpPreference -ExclusionPath "$env:TEMP" -ErrorAction SilentlyContinue
            Set-MpPreference -ScanScheduleQuickScanTime 02:00:00 -ErrorAction SilentlyContinue
            Write-Host "‚úÖ Windows Defender optimized with exclusions"
        } catch {
            Write-Host "‚ö†Ô∏è Windows Defender optimization partially applied"
        }
        
        # Configure Windows Update for minimal interference
        try {
            Set-Service -Name "wuauserv" -StartupType Manual -ErrorAction SilentlyContinue
            Write-Host "‚úÖ Windows Update set to manual"
        } catch {
            Write-Host "‚ö†Ô∏è Could not modify Windows Update service"
        }
        
        # Optimize network for RDP
        netsh int tcp set global autotuninglevel=normal 2>$null
        netsh int tcp set global chimney=enabled 2>$null
        netsh int tcp set global rss=enabled 2>$null
        
        # Set time zone to UTC for consistency
        tzutil /s "UTC" 2>$null
        
        Write-Host "‚úÖ Final optimizations applied"
    
    - name: Start Playit Agent with Monitoring
      env:
        PLAYIT_AUTH_KEY: ${{ secrets.PL }}
      run: |
        Write-Host "üöÄ Starting Playit Agent with monitoring..."
        
        if (-not $env:PLAYIT_AUTH_KEY) {
            Write-Host "‚ùå PLAYIT_AUTH_KEY secret not configured"
            exit 1
        }
        
        try {
            # Start Playit Agent with proper configuration
            $playitPath = "$env:USERPROFILE\playit.exe"
            $logPath = "$env:USERPROFILE\playit.log"
            
            # Start process with logging
            $startInfo = New-Object System.Diagnostics.ProcessStartInfo
            $startInfo.FileName = $playitPath
            $startInfo.Arguments = "--secret `"$env:PLAYIT_AUTH_KEY`""
            $startInfo.UseShellExecute = $false
            $startInfo.RedirectStandardOutput = $true
            $startInfo.RedirectStandardError = $true
            $startInfo.CreateNoWindow = $true
            
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $startInfo
            $process.Start() | Out-Null
            
            # Set high priority but not realtime for stability
            $process.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::High
            
            Write-Host "‚úÖ Playit Agent started (PID: $($process.Id)) with HIGH priority"
            
            # Wait for initialization and verify
            Start-Sleep -Seconds 20
            
            $runningProcess = Get-Process -Id $process.Id -ErrorAction SilentlyContinue
            if ($runningProcess) {
                Write-Host "‚úÖ Playit Agent is running and stable"
                Write-Host "üìä Process Status: Running with PID $($process.Id)"
            } else {
                Write-Host "‚ö†Ô∏è Playit Agent process check inconclusive"
            }
            
        } catch {
            Write-Host "‚ùå Error starting Playit Agent: $($_.Exception.Message)"
            exit 1
        }
    
    - name: System Status and Health Check
      run: |
        Write-Host "üìä System Status and Health Check"
        Write-Host "================================="
        
        # Display system information
        try {
            $cpu = Get-CimInstance -ClassName Win32_Processor
            $memory = Get-CimInstance -ClassName Win32_OperatingSystem
            $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'"
            
            if ($cpu) {
                Write-Host "üñ•Ô∏è CPU: $($cpu.Name)"
                Write-Host "   Cores: $($cpu.NumberOfLogicalProcessors)"
                Write-Host "   Speed: $($cpu.MaxClockSpeed) MHz"
            }
            
            if ($memory) {
                $totalMemGB = [math]::Round($memory.TotalVisibleMemorySize / 1MB, 2)
                $freeMemGB = [math]::Round($memory.FreePhysicalMemory / 1MB, 2)
                $usedMemGB = $totalMemGB - $freeMemGB
                Write-Host "üíæ Memory: $usedMemGB GB / $totalMemGB GB used"
            }
            
            if ($disk) {
                $diskSizeGB = [math]::Round($disk.Size / 1GB, 2)
                $diskFreeGB = [math]::Round($disk.FreeSpace / 1GB, 2)
                Write-Host "üíΩ Disk C: $diskFreeGB GB free / $diskSizeGB GB total"
            }
        } catch {
            Write-Host "‚ö†Ô∏è Could not retrieve some system information"
        }
        
        # Check services status
        $rdpServices = @("TermService", "SessionEnv", "UmRdpService")
        Write-Host "`nüîß RDP Services Status:"
        foreach ($service in $rdpServices) {
            try {
                $svc = Get-Service -Name $service -ErrorAction SilentlyContinue
                if ($svc) {
                    Write-Host "   $service`: $($svc.Status)"
                }
            } catch {
                Write-Host "   $service`: Status unknown"
            }
        }
        
        # Check power scheme
        try {
            $powerScheme = powercfg -getactivescheme
            if ($powerScheme -match "Ultimate|High performance") {
                Write-Host "`n‚ö° Power Scheme: Optimized for performance"
            } else {
                Write-Host "`n‚ö° Power Scheme: $powerScheme"
            }
        } catch {
            Write-Host "`n‚ö° Power Scheme: Could not determine"
        }
        
        Write-Host "`n‚úÖ System health check completed"
    
    - name: Maintain Stable Connection
      run: |
        Write-Host "üîÑ Starting connection maintenance loop..."
        Write-Host "========================================"
        Write-Host "üöÄ HIGH PERFORMANCE RDP TUNNEL IS ACTIVE!"
        Write-Host ""
        Write-Host "üìã CONNECTION DETAILS:"
        Write-Host "   üë§ Username: $env:RDP_USERNAME"
        Write-Host "   üîë Password: $env:RDP_PASSWORD"
        Write-Host "   üîê Access Level: Administrator"
        Write-Host "   ‚ö° Performance: High (Stable Configuration)"
        Write-Host "   üñ•Ô∏è Visual Effects: Optimized for RDP"
        Write-Host "   üõ°Ô∏è Security: Balanced"
        Write-Host ""
        Write-Host "‚è∞ Session will remain active for 360 minutes (6 hours)..."
        Write-Host "üîÑ Starting intelligent monitoring..."
        
        $endTime = (Get-Date).AddMinutes(360)
        $checkInterval = 300  # 5 minutes between checks
        $lastHealthCheck = Get-Date
        $reconnectAttempts = 0
        $maxReconnectAttempts = 3
        
        while ((Get-Date) -lt $endTime) {
            $currentTime = Get-Date
            $remainingMinutes = [math]::Floor(($endTime - $currentTime).TotalMinutes)
            
            # Perform health check every 5 minutes
            if (($currentTime - $lastHealthCheck).TotalSeconds -ge $checkInterval) {
                Write-Host "`n=== üîç Health Check at $($currentTime.ToString('HH:mm:ss')) ==="
                Write-Host "‚è∞ Time remaining: $remainingMinutes minutes"
                
                # Check Playit Agent
                $playitProcess = Get-Process -Name "playit*" -ErrorAction SilentlyContinue
                if ($playitProcess) {
                    Write-Host "‚úÖ Playit Agent: HEALTHY (PID: $($playitProcess.Id))"
                    $reconnectAttempts = 0  # Reset counter
                    
                    # Ensure high priority is maintained
                    if ($playitProcess.PriorityClass -ne "High") {
                        $playitProcess.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::High
                        Write-Host "üîß Priority restored to HIGH"
                    }
                } else {
                    Write-Host "‚ö†Ô∏è Playit Agent not detected"
                    if ($reconnectAttempts -lt $maxReconnectAttempts) {
                        Write-Host "üîÑ Attempting restart ($($reconnectAttempts + 1)/$maxReconnectAttempts)..."
                        try {
                            $newProcess = Start-Process -FilePath "$env:USERPROFILE\playit.exe" -ArgumentList "--secret", "$env:PLAYIT_AUTH_KEY" -WindowStyle Hidden -PassThru
                            if ($newProcess) {
                                $newProcess.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::High
                                Write-Host "‚úÖ Playit Agent restarted successfully"
                                Start-Sleep -Seconds 10
                            }
                        } catch {
                            Write-Host "‚ùå Restart attempt failed: $($_.Exception.Message)"
                        }
                        $reconnectAttempts++
                    } else {
                        Write-Host "‚ùå Maximum restart attempts reached"
                    }
                }
                
                # Check RDP services
                $criticalServices = @("TermService")
                foreach ($service in $criticalServices) {
                    try {
                        $svc = Get-Service -Name $service -ErrorAction SilentlyContinue
                        if ($svc -and $svc.Status -eq "Running") {
                            Write-Host "‚úÖ $service`: Running"
                        } else {
                            Write-Host "‚ö†Ô∏è $service`: Not running - attempting start"
                            Start-Service -Name $service -ErrorAction SilentlyContinue
                        }
                    } catch {
                        Write-Host "‚ùå Could not check $service"
                    }
                }
                
                # Memory usage check
                try {
                    $memory = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction SilentlyContinue
                    if ($memory) {
                        $memUsedPercent = [math]::Round((($memory.TotalVisibleMemorySize - $memory.FreePhysicalMemory) / $memory.TotalVisibleMemorySize) * 100, 1)
                        Write-Host "üíæ Memory Usage: $memUsedPercent%"
                        
                        # If memory usage is very high, force garbage collection
                        if ($memUsedPercent -gt 85) {
                            Write-Host "üßπ High memory usage detected - performing cleanup"
                            [System.GC]::Collect()
                            [System.GC]::WaitForPendingFinalizers()
                        }
                    }
                } catch {
                    Write-Host "üíæ Memory: Status check skipped"
                }
                
                $lastHealthCheck = $currentTime
                Write-Host "=== Health check completed ===`n"
            }
            
            # Light activity to prevent idle timeout
            if ((Get-Random -Minimum 1 -Maximum 100) -eq 1) {
                Get-Date | Out-Null  # Minimal CPU activity
            }
            
            Start-Sleep -Seconds 30
        }
        
        Write-Host "`nüèÅ SESSION COMPLETED SUCCESSFULLY!"
        Write-Host "üìä Runtime: 6 hours"
        Write-Host "üìà Final Status: All services maintained stable connection"
        Write-Host "üéØ Connection quality: Optimized throughout session"