name: Persistent Playit RDP Tunnel

on:
  workflow_dispatch:

jobs:
  setup-rdp-tunnel:
    runs-on: windows-latest

    steps:
    - name: üõ†Ô∏è Check out the repository
      uses: actions/checkout@v2

    # Install Playit with Resilience
    - name: üì• Download and Install Playit
      run: |
        $PlayitPath = "$env:USERPROFILE\playit.exe"
        
        # Try first download method
        Invoke-WebRequest -Uri "https://github.com/playit-cloud/playit-agent/releases/download/v0.15.26/playit-windows-x86_64-signed.exe" -OutFile $PlayitPath -ErrorAction SilentlyContinue
        
        # If first method fails, try another source
        if (!(Test-Path $PlayitPath)) {
            Invoke-WebRequest -Uri "https://dl.playit.gg/playit-windows.exe" -OutFile $PlayitPath
        }

        # Verify installation
        if (!(Test-Path $PlayitPath)) {
            Write-Host "‚ùå Playit download failed."
            exit 1
        }

    # Enable RDP and Keep Active After Reboot
    - name: üîì Enable and Persist RDP
      run: |
        # Enable RDP
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
        Set-LocalUser -Name "runneradmin" -Password (ConvertTo-SecureString -AsPlainText "p@ssw0rd!" -Force)
        
        # Enable multiple RDP sessions
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fSingleSessionPerUser" -Value 0

        # Ensure RDP service starts on reboot
        Set-Service -Name TermService -StartupType Automatic

    # Persistent Playit Execution
    - name: üîÑ Register Playit as a Scheduled Task
      run: |
        $PlayitPath = "$env:USERPROFILE\playit.exe"
        
        # Remove existing task if any
        schtasks /delete /tn "PlayitTunnel" /f
        
        # Create new scheduled task
        schtasks /create /tn "PlayitTunnel" /tr "$PlayitPath --secret $env:PLAYIT_AUTH_KEY" /sc onlogon /rl highest

    # Start Playit Immediately
    - name: üöÄ Start Playit
      env:
        PLAYIT_AUTH_KEY: ${{ secrets.PL }}
      run: |
        Start-Process -FilePath "$env:USERPROFILE\playit.exe" -ArgumentList "--secret $env:PLAYIT_AUTH_KEY" -NoNewWindow

    # Enable Virtualization (Hyper-V, VM Support)
    - name: üñ•Ô∏è Enable Virtualization Support
      run: |
        # Enable Hyper-V
        bcdedit /set hypervisorlaunchtype Auto
        Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-All -NoRestart -ErrorAction SilentlyContinue

        # Alternative: Enable Virtual Machine Platform
        Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart -ErrorAction SilentlyContinue

        # Alternative: Use DISM if previous methods fail
        DISM /Online /Enable-Feature /FeatureName:HypervisorPlatform /All /NoRestart

    # Set Ultimate Performance Mode
    - name: ‚ö° Unlock Ultimate Performance Mode
      run: |
        powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61
        powercfg /S e9a42b02-d5df-448d-aa00-03f14749eb61

    # Install Winget (Multiple Methods)
    - name: üì¶ Install WinGet
      run: |
        $WinGetPath = "$env:USERPROFILE\WinGet.msixbundle"
        
        # Try direct MSIXBUNDLE install
        Invoke-WebRequest -Uri "https://aka.ms/getwinget" -OutFile $WinGetPath
        Add-AppxPackage -Path $WinGetPath -ErrorAction SilentlyContinue

        # Alternative: Use DISM
        if (!(Get-Command winget -ErrorAction SilentlyContinue)) {
            DISM /Online /Add-Package /PackagePath:$WinGetPath
        }

        # Final Check
        if (!(Get-Command winget -ErrorAction SilentlyContinue)) {
            Write-Host "‚ùå WinGet installation failed."
            exit 1
        }

    # Keep GitHub Actions Runner Alive
    - name: üõ°Ô∏è Keep Runner Alive
      run: |
        while ($true) {
          Write-Host "Keeping runner alive... $(Get-Date)"
          Start-Sleep -Seconds 300
        }
