name: Playit RDP Tunnel (MAXIMUM CPU POWER)
on:
  workflow_dispatch:
jobs:
  setup-rdp-tunnel:
    runs-on: windows-latest
    steps:
    - name: Check out the repository
      uses: actions/checkout@v2
    
    - name: MAXIMIZE System Performance and CPU Power
      run: |
        # Set Windows to Ultimate High Performance mode
        powercfg -setactive SCHEME_MIN
        
        # Force ALL CPU cores to maximum usage
        try {
            bcdedit /set numproc 0
        } catch {
            Write-Host "Could not modify boot config, continuing..."
        }
        
        # DISABLE ALL POWER SAVING - MAXIMUM PERFORMANCE
        powercfg -change standby-timeout-ac 0
        powercfg -change standby-timeout-dc 0
        powercfg -change hibernate-timeout-ac 0
        powercfg -change hibernate-timeout-dc 0
        powercfg -change disk-timeout-ac 0
        powercfg -change disk-timeout-dc 0
        powercfg -change monitor-timeout-ac 0
        powercfg -change monitor-timeout-dc 0
        
        # FORCE CPU TO 100% PERFORMANCE - NO THROTTLING
        try {
            $guid = (powercfg -getactivescheme).Split()[3]
            powercfg -setacvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMAX 100
            powercfg -setacvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMIN 100
            powercfg -setdcvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMAX 100
            powercfg -setdcvalueindex $guid SUB_PROCESSOR PROCTHROTTLEMIN 100
            # Disable CPU parking completely
            powercfg -setacvalueindex $guid SUB_PROCESSOR CPMINCORES 100
            powercfg -setdcvalueindex $guid SUB_PROCESSOR CPMINCORES 100
            # Set CPU frequency to maximum
            powercfg -setacvalueindex $guid SUB_PROCESSOR PERFBOOSTMODE 2
            powercfg -setdcvalueindex $guid SUB_PROCESSOR PERFBOOSTMODE 2
            powercfg -setactive $guid
        } catch {
            Write-Host "Could not modify CPU throttling settings, using alternative approach..."
        }
        
        # Configure pagefile for maximum performance
        try {
            $cs = Get-CimInstance -ClassName Win32_ComputerSystem
            if ($cs.AutomaticManagedPagefile) {
                Set-CimInstance -InputObject $cs -Property @{AutomaticManagedPagefile=$false}
            }
            Get-CimInstance -ClassName Win32_PageFileSetting | Remove-CimInstance -ErrorAction SilentlyContinue
            New-CimInstance -ClassName Win32_PageFileSetting -Property @{
                Name = "C:\pagefile.sys"
                InitialSize = 6144  # 6GB
                MaximumSize = 12288 # 12GB
            } -ErrorAction SilentlyContinue
        } catch {
            Write-Host "Could not configure pagefile, using system defaults..."
        }
        
        # Stop ALL unnecessary services for maximum CPU availability
        $servicesToStop = @("wuauserv", "Spooler", "Fax", "Themes", "TabletInputService", "WSearch", 
                          "SysMain", "Superfetch", "DiagTrack", "dmwappushservice", "MapsBroker",
                          "lfsvc", "SharedAccess", "RemoteRegistry", "TrkWks", "WbioSrvc")
        foreach ($service in $servicesToStop) {
            try {
                $svc = Get-Service -Name $service -ErrorAction SilentlyContinue
                if ($svc -and $svc.Status -eq 'Running') {
                    Stop-Service -Name $service -Force -ErrorAction SilentlyContinue
                    Set-Service -Name $service -StartupType Disabled -ErrorAction SilentlyContinue
                    Write-Host "Stopped and disabled service: $service"
                }
            } catch {
                Write-Host "Could not modify service: $service"
            }
        }
        
        # Disable Windows Defender completely
        try {
            Set-MpPreference -DisableRealtimeMonitoring $true -ErrorAction SilentlyContinue
            Set-MpPreference -DisableBehaviorMonitoring $true -ErrorAction SilentlyContinue
            Set-MpPreference -DisableIOAVProtection $true -ErrorAction SilentlyContinue
            Set-MpPreference -DisablePrivacyMode $true -ErrorAction SilentlyContinue
            Set-MpPreference -DisableIntrusionPreventionSystem $true -ErrorAction SilentlyContinue
            Write-Host "Disabled Windows Defender completely"
        } catch {
            Write-Host "Could not disable Windows Defender"
        }
        
        # Set system to MAXIMUM performance priority
        try {
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name "Win32PrioritySeparation" -Value 26 -ErrorAction SilentlyContinue
            # Set system to favor background services (for our CPU tasks)
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name "IRQ8Priority" -Value 1 -ErrorAction SilentlyContinue
            Write-Host "Set system priority to MAXIMUM performance"
        } catch {
            Write-Host "Could not modify system priority settings"
        }
        
        # Set current process to REALTIME priority (highest possible)
        try {
            [System.Diagnostics.Process]::GetCurrentProcess().PriorityClass = 'RealTime'
        } catch {
            [System.Diagnostics.Process]::GetCurrentProcess().PriorityClass = 'High'
        }
        
        Write-Host "System optimization for MAXIMUM CPU performance completed!"
    
    - name: Download and Install Playit Agent
      run: |
        Write-Host "Downloading Playit Agent..."
        Invoke-WebRequest -Uri "https://github.com/playit-cloud/playit-agent/releases/download/v0.15.26/playit-windows-x86_64-signed.exe" -OutFile "$env:USERPROFILE\playit.exe"
        Write-Host "Playit Agent downloaded successfully"
        Start-Sleep -Seconds 3
    
    - name: Enable Remote Desktop and Configure
      run: |
        Write-Host "Configuring Remote Desktop for maximum performance..."
        # Enable Remote Desktop
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        
        # Enable Network Level Authentication
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
        
        # Maximize RDP connections
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "MaxInstanceCount" -Value 20
        
        # Set RDP to use maximum bandwidth
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "MaxConnectionTime" -Value 0
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "MaxIdleTime" -Value 0
        Write-Host "Remote Desktop configured for maximum performance"
    
    - name: Set RDP Password
      shell: powershell
      run: |
        Write-Host "Setting up RDP user account..."
        # Keep original password and username as requested
        $password = ConvertTo-SecureString "P@ssword123" -AsPlainText -Force
        if (-not (Get-LocalUser -Name "runneradmin" -ErrorAction SilentlyContinue)) {
          Write-Host "Creating user 'runneradmin'..."
          New-LocalUser -Name "runneradmin" -Password $password -FullName "GitHub Runner Admin" -Description "Admin account for RDP access"
          Add-LocalGroupMember -Group "Administrators" -Member "runneradmin"
        }
        else {
          Write-Host "User 'runneradmin' already exists. Updating password..."
          Set-LocalUser -Name "runneradmin" -Password $password
        }
        Write-Host "RDP user account configured successfully"
    
    - name: Start Playit Agent with Maximum Priority
      env:
        PLAYIT_AUTH_KEY: ${{ secrets.PL }}
      run: |
        Write-Host "Starting Playit Agent with MAXIMUM priority..."
        # Start the Playit Agent with REALTIME priority
        $process = Start-Process -FilePath "$env:USERPROFILE\playit.exe" -ArgumentList "--secret $env:PLAYIT_AUTH_KEY" -WindowStyle Hidden -PassThru
        try {
            $process.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::RealTime
            Write-Host "Playit Agent started with RealTime priority"
        } catch {
            $process.PriorityClass = [System.Diagnostics.ProcessPriorityClass]::High
            Write-Host "Playit Agent started with High priority"
        }
        Start-Sleep -Seconds 5
        Write-Host "Playit Agent is running and ready"
    
    - name: Initialize MAXIMUM CPU Utilization System
      run: |
        Write-Host "Initializing MAXIMUM CPU utilization system..."
        
        # Get actual CPU core count
        $coreCount = (Get-WmiObject -Class Win32_Processor | Measure-Object -Property NumberOfLogicalProcessors -Sum).Sum
        Write-Host "Detected $coreCount CPU cores/threads - preparing maximum utilization"
        
        # Create global flag file for CPU jobs
        $flagFile = "$env:TEMP\cpu_jobs_active.flag"
        "ACTIVE" | Out-File -FilePath $flagFile -Force
        
        # Create CPU-intensive jobs for EACH logical processor
        for ($i = 1; $i -le $coreCount; $i++) {
            Start-Job -ScriptBlock {
                param($coreId, $flagFilePath)
                # Set this job to high priority
                try {
                    [System.Diagnostics.Process]::GetCurrentProcess().PriorityClass = 'High'
                } catch {}
                
                # MAXIMUM CPU intensive operations with flag checking
                while (Test-Path $flagFilePath) {
                    # Multiple types of CPU-intensive calculations
                    $result = 0
                    
                    # Mathematical calculations
                    for ($j = 1; $j -le 1000000; $j++) {
                        $result += [Math]::Sqrt($j) * [Math]::Sin($j % 1000) * [Math]::Cos($j % 1000)
                        # Check flag every 100k iterations to allow for graceful shutdown
                        if ($j % 100000 -eq 0 -and !(Test-Path $flagFilePath)) { break }
                    }
                    
                    # Prime number calculations
                    for ($k = 1000; $k -le 1500; $k++) {
                        if (!(Test-Path $flagFilePath)) { break }
                        $isPrime = $true
                        for ($l = 2; $l -le [Math]::Sqrt($k); $l++) {
                            if ($k % $l -eq 0) {
                                $isPrime = $false
                                break
                            }
                        }
                    }
                    
                    # Fibonacci calculations
                    if (Test-Path $flagFilePath) {
                        $fib1, $fib2 = 0, 1
                        for ($m = 0; $m -lt 50000; $m++) {
                            $temp = $fib1 + $fib2
                            $fib1 = $fib2
                            $fib2 = $temp
                        }
                    }
                    
                    # Brief check to prevent excessive resource locking
                    if (!(Test-Path $flagFilePath)) { break }
                }
            } -ArgumentList $i, $flagFile -Name "MaxCPULoad_Core$i"
        }
        
        # Create additional CPU stress jobs for MAXIMUM load
        for ($extra = 1; $extra -le ($coreCount); $extra++) {
            Start-Job -ScriptBlock {
                param($jobId, $flagFilePath)
                try {
                    [System.Diagnostics.Process]::GetCurrentProcess().PriorityClass = 'High'
                } catch {}
                
                while (Test-Path $flagFilePath) {
                    # Cryptographic operations (very CPU intensive)
                    $data = [System.Text.Encoding]::UTF8.GetBytes("MaximumCPUStress" * 500)
                    $sha256 = [System.Security.Cryptography.SHA256]::Create()
                    for ($i = 0; $i -lt 500; $i++) {
                        if (!(Test-Path $flagFilePath)) { break }
                        $hash = $sha256.ComputeHash($data)
                        $data = $hash
                    }
                    $sha256.Dispose()
                    
                    # String manipulation (CPU intensive)
                    if (Test-Path $flagFilePath) {
                        $str = "CPUStressTest" * 500
                        for ($i = 0; $i -lt 5000; $i++) {
                            if (!(Test-Path $flagFilePath)) { break }
                            $str = $str.Replace("C", "X").Replace("P", "Y").Replace("U", "Z")
                            $str = $str.Substring(0, [Math]::Min($str.Length, 25000))
                        }
                    }
                }
            } -ArgumentList $extra, $flagFile -Name "ExtraCPUStress$extra"
        }
        
        Write-Host "Started $($coreCount * 2) MAXIMUM CPU-intensive background jobs"
        Write-Host "Total active jobs: $((Get-Job | Where-Object {$_.State -eq 'Running'}).Count)"
        Write-Host "CPU utilization system initialized and running at maximum capacity"
    
    - name: Start Memory and I/O Support Systems
      run: |
        Write-Host "Starting memory and I/O support systems..."
        $flagFile = "$env:TEMP\cpu_jobs_active.flag"
        
        # Memory support job
        Start-Job -ScriptBlock {
            param($flagFilePath)
            $arrays = @()
            $maxArrays = 15
            while (Test-Path $flagFilePath) {
                try {
                    $array = New-Object byte[] (50MB)
                    $arrays += $array
                    if ($arrays.Count -gt $maxArrays) {
                        $arrays = $arrays[5..$($maxArrays-1)]
                        [System.GC]::Collect()
                        [System.GC]::WaitForPendingFinalizers()
                    }
                    
                    # Memory-intensive operations
                    for ($i = 0; $i -lt $array.Length; $i += 2000) {
                        if (!(Test-Path $flagFilePath)) { break }
                        $array[$i] = [byte](Get-Random -Maximum 256)
                    }
                    
                    Start-Sleep -Milliseconds 200
                } catch {
                    [System.GC]::Collect()
                    Start-Sleep -Seconds 3
                }
            }
        } -ArgumentList $flagFile -Name "MemoryIntensiveLoad"
        
        # Disk I/O support job
        Start-Job -ScriptBlock {
            param($flagFilePath)
            $counter = 0
            $tempDir = "$env:TEMP\maxcpuload"
            New-Item -Path $tempDir -ItemType Directory -Force -ErrorAction SilentlyContinue
            
            while (Test-Path $flagFilePath) {
                try {
                    $fileName = "$tempDir\cpu_stress_$counter.tmp"
                    $data = [byte[]]::new(25MB)
                    
                    # Fill with random data (CPU intensive)
                    for ($i = 0; $i -lt $data.Length; $i += 2000) {
                        if (!(Test-Path $flagFilePath)) { break }
                        $data[$i] = [byte](Get-Random -Maximum 256)
                    }
                    
                    if (Test-Path $flagFilePath) {
                        [System.IO.File]::WriteAllBytes($fileName, $data)
                        $readData = [System.IO.File]::ReadAllBytes($fileName)
                        
                        # Checksum calculation (CPU intensive)
                        $checksum = 0
                        for ($i = 0; $i -lt $readData.Length; $i += 200) {
                            $checksum += $readData[$i]
                        }
                        
                        Remove-Item $fileName -Force -ErrorAction SilentlyContinue
                    }
                    
                    $counter++
                    if ($counter -gt 15) {
                        $counter = 0
                        Get-ChildItem $tempDir -File | Remove-Item -Force -ErrorAction SilentlyContinue
                    }
                    
                    Start-Sleep -Milliseconds 100
                } catch {
                    Start-Sleep -Seconds 3
                }
            }
        } -ArgumentList $flagFile -Name "MaxDiskIOLoad"
        
        Write-Host "Memory and I/O support systems started successfully"
    
    - name: Monitor Initial Resource Usage
      run: |
        Write-Host "=== INITIAL MAXIMUM SYSTEM RESOURCE USAGE ==="
        Write-Host "Active Background Jobs: $((Get-Job | Where-Object {$_.State -eq 'Running'}).Count)"
        Get-Job | Format-Table Name, State -AutoSize
        
        # Show memory usage
        $memory = Get-CimInstance -ClassName Win32_OperatingSystem
        $totalMemory = [math]::Round($memory.TotalVisibleMemorySize / 1KB, 2)
        $freeMemory = [math]::Round($memory.FreePhysicalMemory / 1KB, 2)
        $usedMemory = $totalMemory - $freeMemory
        Write-Host "Memory Usage: $usedMemory GB / $totalMemory GB ($(($usedMemory/$totalMemory*100).ToString('F1'))%)"
        
        # Show CPU core information
        $cpu = Get-CimInstance -ClassName Win32_Processor
        Write-Host "CPU Cores: $($cpu.NumberOfCores), Logical Processors: $($cpu.NumberOfLogicalProcessors)"
        Write-Host "CPU Max Clock Speed: $($cpu.MaxClockSpeed) MHz"
        Write-Host "System configured for MAXIMUM CPU utilization - all cores active"
    
    - name: Keep GitHub Runner Alive with MAXIMUM CPU Utilization
      run: |
        Write-Host "=========================================="
        Write-Host "RDP Tunnel Active with ABSOLUTE MAXIMUM CPU UTILIZATION"
        Write-Host "All CPU cores running at maximum capacity!"
        Write-Host "Total background processes: $((Get-Job | Where-Object {$_.State -eq 'Running'}).Count)"
        Write-Host "=========================================="
        
        $flagFile = "$env:TEMP\cpu_jobs_active.flag"
        
        # Keep the session alive for 6 hours while maintaining MAXIMUM CPU usage
        $endTime = (Get-Date).AddHours(6)
        $checkInterval = 0
        
        try {
            while ((Get-Date) -lt $endTime) {
                # Additional CPU-intensive operations in main thread
                $intensiveOperations = 1..5000 | ForEach-Object { 
                    [Math]::Pow($_, 2) + [Math]::Sqrt($_) + [Math]::Sin($_ % 1000)
                }
                
                # Calculate pi using CPU-intensive method
                $pi = 0
                for ($i = 1; $i -le 25000; $i++) {
                    $pi += [Math]::Pow(-1, $i + 1) / (2 * $i - 1)
                }
                $pi *= 4
                
                # Every 15 minutes, show resource usage and maintain jobs
                $checkInterval++
                if ($checkInterval -ge 30) { # 30 * 30 seconds = 15 minutes
                    $checkInterval = 0
                    Write-Host "=== CPU UTILIZATION CHECK at $(Get-Date) ==="
                    
                    # Show job status
                    $runningJobs = (Get-Job | Where-Object {$_.State -eq 'Running'}).Count
                    $totalJobs = (Get-Job).Count
                    Write-Host "Running Jobs: $runningJobs / $totalJobs"
                    
                    # Restart any failed jobs to maintain maximum CPU usage
                    $failedJobs = Get-Job | Where-Object {$_.State -eq 'Failed' -or $_.State -eq 'Stopped'}
                    if ($failedJobs) {
                        Write-Host "Restarting $($failedJobs.Count) failed jobs for maximum CPU usage..."
                        $failedJobs | Remove-Job -Force
                        
                        # Restart high-intensity CPU jobs
                        for ($restart = 1; $restart -le [Math]::Min(4, $failedJobs.Count); $restart++) {
                            Start-Job -ScriptBlock {
                                param($flagFilePath)
                                try {
                                    [System.Diagnostics.Process]::GetCurrentProcess().PriorityClass = 'High'
                                } catch {}
                                while (Test-Path $flagFilePath) {
                                    $result = 0
                                    for ($j = 1; $j -le 1500000; $j++) {
                                        $result += [Math]::Sqrt($j) * [Math]::Sin($j % 1000) * [Math]::Cos($j % 1000)
                                        if ($j % 100000 -eq 0 -and !(Test-Path $flagFilePath)) { break }
                                    }
                                }
                            } -ArgumentList $flagFile -Name "RestartedCPULoad$restart"
                        }
                    }
                    
                    Write-Host "System maintaining MAXIMUM CPU stress - all available cores utilized"
                    
                    # Show current system stats
                    $memory = Get-CimInstance -ClassName Win32_OperatingSystem
                    $usedMemoryPercent = (($memory.TotalVisibleMemorySize - $memory.FreePhysicalMemory) / $memory.TotalVisibleMemorySize * 100).ToString('F1')
                    Write-Host "Current Memory Usage: $usedMemoryPercent%"
                }
                
                Start-Sleep -Seconds 30
            }
        }
        finally {
            # Cleanup: Remove flag file to stop all CPU jobs gracefully
            Write-Host "Session completing - stopping CPU utilization jobs..."
            if (Test-Path $flagFile) {
                Remove-Item $flagFile -Force -ErrorAction SilentlyContinue
            }
            
            # Wait a moment for jobs to complete gracefully
            Start-Sleep -Seconds 10
            
            # Clean up any remaining jobs
            Get-Job | Stop-Job -ErrorAction SilentlyContinue
            Get-Job | Remove-Job -Force -ErrorAction SilentlyContinue
            
            # Clean up temp directory
            $tempDir = "$env:TEMP\maxcpuload"
            if (Test-Path $tempDir) {
                Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
            }
            
            Write-Host "Session completed after 6 hours of MAXIMUM CPU utilization"
            Write-Host "All background jobs stopped and resources cleaned up"
        }