name: Persistent Playit RDP Tunnel

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */5 * * *"  # Restarts every 5 hours to avoid the 6-hour limit

permissions:
  actions: write
  contents: write

jobs:
  setup-rdp-tunnel:
    runs-on: windows-latest

    steps:
    - name: Check out the repository
      uses: actions/checkout@v3

    # âœ… Restore previous progress if available
    - name: Restore Previous Progress (Optional)
      uses: actions/download-artifact@v4
      continue-on-error: true  # Prevents failure if artifact doesn't exist
      with:
        name: progress
        path: ./progress

    - name: Debug GitHub Actions Connectivity
      run: |
        echo "Checking GitHub API..."
        curl -sL "https://api.github.com/repos/actions/upload-artifact/releases/latest"
        echo "Checking Internet Connection..."
        nslookup github.com

    - name: Load Last Execution Step
      id: load-progress
      run: |
        New-Item -ItemType Directory -Path "./progress" -Force  # âœ… Ensure the folder exists
    
        if (Test-Path ./progress/last_step.txt) {
          $LAST_STEP = Get-Content ./progress/last_step.txt
          echo "step=$LAST_STEP" | Out-File -FilePath $env:GITHUB_ENV -Append  # âœ… New method
          Write-Host "Resuming from step $LAST_STEP"
        } else {
          echo "step=0" | Out-File -FilePath $env:GITHUB_ENV -Append  # âœ… New method
          Write-Host "Starting from Step 0"
        }

    - name: Download and Install Playit
      if: steps.load-progress.outputs.step == '0'
      run: |
        New-Item -ItemType Directory -Path "./progress" -Force  # âœ… Ensure folder exists
        Invoke-WebRequest -Uri "https://github.com/playit-cloud/playit-agent/releases/download/v0.15.26/playit-windows-x86_64-signed.exe" -OutFile "$env:USERPROFILE\playit.exe"
        Start-Sleep -Seconds 5
        echo "1" | Out-File -FilePath "./progress/last_step.txt" -Encoding utf8  # âœ… Write safely
    
    # âœ… Enable Virtualization & Hyper-V
    - name: Enable Virtualization & Hyper-V
      if: steps.load-progress.outputs.step == '1'
      run: |
        Write-Host "ðŸ”„ Checking if system supports Hyper-V..."
        
        # âœ… Check if system supports Hyper-V
        $hyperVSupport = Get-WindowsOptionalFeature -Online | Where-Object { $_.FeatureName -like "*Hyper-V*" }
        if (-not $hyperVSupport) {
            Write-Host "âŒ This system does not support Hyper-V. Exiting..."
            exit 1
        } else {
            Write-Host "âœ… System supports Hyper-V!"
        }
        
        # âœ… Enable Virtualization in Boot Configuration
        Write-Host "ðŸ”„ Enabling Virtualization..."
        bcdedit /set hypervisorlaunchtype Auto
        if ($?) {
            Write-Host "âœ… Virtualization Enabled!"
        } else {
            Write-Host "âŒ Failed to enable Virtualization. Check BIOS settings."
            exit 1
        }
        
        # âœ… List of Hyper-V Features
        $features = @(
            "Microsoft-Hyper-V-All",
            "Microsoft-Hyper-V",
            "Microsoft-Hyper-V-Platform",
            "Microsoft-Hyper-V-Management-Tools",
            "HypervisorPlatform"
        )
        
        # âœ… METHOD 1: Enable Hyper-V using Enable-WindowsOptionalFeature
        Write-Host "ðŸ”„ Enabling Hyper-V using Windows Features..."
        foreach ($feature in $features) {
            Try {
                Write-Host "ðŸ”„ Enabling $feature..."
                Enable-WindowsOptionalFeature -Online -FeatureName $feature -NoRestart -ErrorAction Stop
                Write-Host "âœ… Successfully enabled $feature!"
            } Catch {
                Write-Host "âš ï¸ Failed to enable $feature, trying next..."
            }
        }
        
        # âœ… METHOD 2: Check if Hyper-V is fully enabled
        $enabledFeatures = Get-WindowsOptionalFeature -Online | Where-Object { $_.State -eq "Enabled" -and $_.FeatureName -like "*Hyper-V*" }
        if ($enabledFeatures) {
            Write-Host "âœ… Hyper-V is enabled successfully!"
            echo "2" > ./progress/last_step.txt  # Save progress
            exit 0
        } else {
            Write-Host "âš ï¸ Hyper-V installation may not be complete. Checking DISM method..."
        }
        
        # âœ… METHOD 3: Enable Hyper-V using DISM
        Try {
            Write-Host "ðŸ”„ Trying DISM method for Hyper-V..."
            DISM /Online /Enable-Feature /FeatureName:Microsoft-Hyper-V-All /All /NoRestart
            Write-Host "âœ… DISM method executed for Hyper-V!"
        } Catch {
            Write-Host "âš ï¸ DISM method failed. Trying alternative..."
        }
        
        # âœ… METHOD 4: Manually Install Hyper-V (Final Resort)
        Try {
            Write-Host "ðŸ”„ Manually enabling Hyper-V registry settings..."
            New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies" -Name "HyperV" -Value 1 -PropertyType DWord -Force
            Restart-Computer -Force
        } Catch {
            Write-Host "âŒ All installation methods failed. Exiting..."
            exit 1
        }
        
        Write-Host "âœ… Hyper-V installation completed!"
        echo "2" > ./progress/last_step.txt  # Save progress


    # âœ… Enable Remote Desktop (RDP) persistently
    - name: Enable Remote Desktop
      if: steps.load-progress.outputs.step == '2'
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
        Set-LocalUser -Name "runneradmin" -Password (ConvertTo-SecureString -AsPlainText "p@ssw0rd!" -Force)
        echo "3" > ./progress/last_step.txt  # Save progress

    # âœ… Install NSSM (Alternative to Task Scheduler)
    - name: Install NSSM
      if: steps.load-progress.outputs.step == '3'
      run: |
        Invoke-WebRequest -Uri "https://nssm.cc/release/nssm-2.24.zip" -OutFile "$env:TEMP\nssm.zip"
        Expand-Archive -Path "$env:TEMP\nssm.zip" -DestinationPath "$env:TEMP\nssm" -Force
        Copy-Item -Path "$env:TEMP\nssm\nssm-2.24\win64\nssm.exe" -Destination "$env:SystemRoot\System32" -Force
        echo "4" > ./progress/last_step.txt  # Save progress

    # âœ… Create a Windows Service for Playit (Runs in Background)
    - name: Run Playit as a Windows Service (Hidden)
      if: steps.load-progress.outputs.step == '4'
      env:
        PLAYIT_AUTH_KEY: ${{ secrets.PL }}
      run: |
        nssm install PlayitAgent "$env:USERPROFILE\playit.exe" "--secret $env:PLAYIT_AUTH_KEY"
        nssm set PlayitAgent Start SERVICE_AUTO_START
        nssm set PlayitAgent AppNoConsole 1
        nssm set PlayitAgent ObjectName LocalSystem
        nssm set PlayitAgent Type SERVICE_WIN32_OWN_PROCESS
        nssm set PlayitAgent AppExit Default Restart
        nssm start PlayitAgent
        echo "5" > ./progress/last_step.txt  # Save progress

    # âœ… Keep GitHub Actions Alive (Restart Workflow Automatically)
    - name: Save Progress
      uses: actions/upload-artifact@v4  # Ensure this is v4 (not v3)
      with:
        name: progress
        path: ./progress/last_step.txt

    - name: Restart Workflow Before Timeout
      env:
        GH_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        $headers = @{
          "Authorization" = "Bearer $env:GH_TOKEN"
          "Accept" = "application/vnd.github.v3+json"
        }
        $body = @{
          "ref" = "main"
        } | ConvertTo-Json -Compress
    
        $workflowFileName = "rdp.yml"  # Ensure this matches your workflow filename
        $repo = "${{ github.repository }}"
        $url = "https://api.github.com/repos/$repo/actions/workflows/$workflowFileName/dispatches"
    
        Write-Host "Triggering workflow dispatch to: $url"
        Invoke-RestMethod -Uri $url -Method Post -Headers $headers -Body $body
      shell: pwsh

    - name: Keep GitHub Action Runner Alive
      run: |
        while ($true) {
          Write-Host "Keeping runner alive... $(Get-Date)"
          Start-Sleep -Seconds 300
        }